<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>time = 0;

falling = true;
moving = true;
type = "";
rot = 0;

IG = 0;

swapped = false;

//speeding = 1;

autoIncDelay = 8;
autoIncSpeed = 5;
slideDir = " ";

//alarm[0] = global.levels[global.level]/speeding;
alarm[1] = -1;
alarm[2] = -1;

if(global.control.type == " ") 
{ 
    type = global.control.preview[0];
    for(i = 0; i &lt; global.control.previewCount-1; i++)
    { global.control.preview[i] = global.control.preview[i+1]; }
    global.control.preview[global.control.previewCount-1] = choose("long", "square", "s", "z", "l", "rl", "t"); 
} 
else 
{ 
    type = global.control.type; 
    global.control.type = " ";
} 


if(type == "long")
{
    segments[0] = instance_create(x+global.segmentSize*2, y-global.segmentSize*0, obj_segment);
    segments[0].parent = id;
    //living[0] = true;
    segments[1] = instance_create(x+global.segmentSize*2, y-global.segmentSize*1, obj_segment);
    segments[1].parent = id;
    //living[1] = true;
    segments[2] = instance_create(x+global.segmentSize*2, y-global.segmentSize*2, obj_segment);    
    segments[2].parent = id;
    //living[2] = true;
    segments[3] = instance_create(x+global.segmentSize*2, y-global.segmentSize*3, obj_segment);
    segments[3].parent = id;
    //living[3] = true;
}
else if(type == "square")
{
    segments[0] = instance_create(x+global.segmentSize*1, y-global.segmentSize*0, obj_segment);
    segments[0].parent = id;
    //living[0] = true;
    segments[1] = instance_create(x+global.segmentSize*2, y-global.segmentSize*0, obj_segment);
    segments[1].parent = id;
    //living[1] = true;
    segments[2] = instance_create(x+global.segmentSize*1, y-global.segmentSize*1, obj_segment);    
    segments[2].parent = id;
    //living[2] = true;
    segments[3] = instance_create(x+global.segmentSize*2, y-global.segmentSize*1, obj_segment);
    segments[3].parent = id;
    //living[3] = true;
}
else if(type == "s")
{
    segments[0] = instance_create(x+global.segmentSize*0, y-global.segmentSize*0, obj_segment);
    segments[0].parent = id;
    //living[0] = true;
    segments[1] = instance_create(x+global.segmentSize*1, y-global.segmentSize*0, obj_segment);
    segments[1].parent = id;
    //living[1] = true;
    segments[2] = instance_create(x+global.segmentSize*1, y-global.segmentSize*1, obj_segment);    
    segments[2].parent = id;
    //living[2] = true;
    segments[3] = instance_create(x+global.segmentSize*2, y-global.segmentSize*1, obj_segment);
    segments[3].parent = id;
    //living[3] = true;
}
else if(type == "z")
{
    segments[0] = instance_create(x+global.segmentSize*0, y-global.segmentSize*1, obj_segment);
    segments[0].parent = id;
    //living[0] = true;
    segments[1] = instance_create(x+global.segmentSize*1, y-global.segmentSize*1, obj_segment);
    segments[1].parent = id;
    //living[1] = true;
    segments[2] = instance_create(x+global.segmentSize*1, y-global.segmentSize*0, obj_segment);    
    segments[2].parent = id;
    //living[2] = true;
    segments[3] = instance_create(x+global.segmentSize*2, y-global.segmentSize*0, obj_segment);
    segments[3].parent = id;
    //living[3] = true;
}
else if(type == "l")
{
    rot = 180;
    segments[0] = instance_create(x, y-global.segmentSize*1, obj_segment);
    segments[0].parent = id;
    segments[1] = instance_create(x+global.segmentSize, y-global.segmentSize*1, obj_segment);
    segments[1].parent = id;
    segments[2] = instance_create(x+global.segmentSize, y+global.segmentSize*0, obj_segment);    
    segments[2].parent = id;
    segments[3] = instance_create(x+global.segmentSize, y+global.segmentSize*1, obj_segment);
    segments[3].parent = id;
}
else if(type == "rl")
{
    rot = 180;
    segments[0] = instance_create(x+global.segmentSize*2, y-global.segmentSize*1, obj_segment);
    segments[0].parent = id;
    segments[1] = instance_create(x+global.segmentSize, y-global.segmentSize*1, obj_segment);
    segments[1].parent = id;
    segments[2] = instance_create(x+global.segmentSize, y+global.segmentSize*0, obj_segment);    
    segments[2].parent = id;
    segments[3] = instance_create(x+global.segmentSize, y+global.segmentSize*1, obj_segment);
    segments[3].parent = id;
}
else if(type == "t")
{
    segments[0] = instance_create(x, y, obj_segment);
    segments[0].parent = id;
    //living[0] = true;
    segments[1] = instance_create(x-global.segmentSize, y, obj_segment);
    segments[1].parent = id;
    //living[1] = true;
    segments[2] = instance_create(x, y+global.segmentSize*1, obj_segment);    
    segments[2].parent = id;
    //living[2] = true;
    segments[3] = instance_create(x+global.segmentSize, y, obj_segment);
    segments[3].parent = id;
    //living[3] = true;
}

for(i = 0; i &lt; 4; i++)
{
    ghosts[i] = instance_create(segments[i].x, segments[i].y, obj_ghostSeg);
    ghosts[i].parent = id;
}

//if(keyboard_check(ord("F"))) { speeding = 4; }
//    else { speeding = 1; }  
if(keyboard_check(vk_left)) 
{
    alarm[3] = autoIncSpeed;
    slideDir = "l";
}
else if(keyboard_check(vk_right)) 
{
    alarm[3] = autoIncSpeed;
    slideDir = "r";
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Slide

alarm[3] = autoIncSpeed;

if(slideDir == "l") 
{  
    if(alarm[1] != -1) 
    { alarm[1] = global.timeToMove; }
    
    canMove = true;
    if(moving)
    {
        leftmost = 0;
        for(i = 0; i &lt; 4; i++)
        {
            if( segments[i].x &lt; segments[leftmost].x ) { leftmost = i; }
        }
    
        if(segments[leftmost].x-global.segmentSize &gt;= 0) 
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( collision_point(segments[i].x-10, segments[i].y-10, obj_segment, false, false) != noone) 
                {
                    if( collision_point(segments[i].x-10, segments[i].y-10, obj_segment, false, false).parent != id  )
                    {
                        canMove = false;
                    }    
                }
            }
        }
        else { canMove = false }
    
        if(canMove)
        {
            for(i = 0; i &lt; 4; i++)
            {
                segments[i].x -= global.segmentSize;
            }
        }
    } 
}
else if( slideDir == "r")
{
    if(alarm[1] != -1) 
    { alarm[1] = global.timeToMove; }
    
    canMove = true;
    if(moving)
    {
        rightMost = 0; 
        for(i = 0; i &lt; 4; i++) 
        { 
            if( (segments[i]).x &gt; (segments[rightMost]).x ) 
            { rightMost = i; } 
        }
        
        if(segments[rightMost].x+10+global.segmentSize &lt; global.width) 
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( collision_point(segments[i].x+global.segmentSize+10, segments[i].y-10, obj_segment, false, false) != noone) 
                {
                    if( collision_point(segments[i].x+global.segmentSize+10, segments[i].y-10, obj_segment, false, false).parent != id  )
                    {
                        canMove = false;
                    }    
                }
            }
        }
        else { canMove = false }
    
        if(canMove)
        {
            for(i = 0; i &lt; 4; i++)
            {
                segments[i].x += global.segmentSize;
            }
        }
    }  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Kill
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///When timeToMove expires, solidify
solidify(id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Falling logic

/*

canMove = true;
if(global.active == id)
{
    if(canMove)
    {
        lowest = 0;
        for(i = 0; i &lt; 4; i++)
        {
            if( segments[i].y &gt; segments[lowest].y) { lowest = i; }    
        }
        
        if(( segments[lowest].y+global.segmentSize) &gt; room_height)    
        {
            yDiff = room_height - segments[lowest].y;
            for(i = 0; i &lt; 4; i++) { segments[i].y += yDiff; }
            if(alarm[1] == -1) { alarm[1] = global.timeToMove; } 
        }
        else 
        {
            canMove = true;
            for(i = 0; i &lt; 4; i++)
            {
                if( collision_point(segments[i].x+10, segments[i].y+global.segmentSize-10, obj_segment, false, false) != noone) 
                {
                    if( collision_point(segments[i].x+10, segments[i].y+global.segmentSize-10, obj_segment, false, false).parent != id  )
                    {
                        canMove = false;
                    }    
                }
            }
            
            if( canMove )
            {
                for( i = 0; i &lt; 4; i++)
                {
                    segments[i].y += global.segmentSize;    
                }
                alarm[1] = -1
                falling = true;
            }
            else 
            { 
                falling = false; 
                if( alarm[1] == -1 ) { alarm[1] = global.timeToMove; }
            }    
        }
        
        
        if(falling) { alarm[0] = global.levels[global.level]/speeding; }
    }
}



*/ 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.active == id and moving)
{
    for(i = 0; i &lt; 4; i++) { ghosts[i].x = segments[i].x; }
        
    lowest = 0;
    for(i = 0; i &lt; 4; i++) 
    { 
        if( (ghosts[i]).y &gt; (ghosts[lowest]).y ) 
        { lowest = i; } 
    }
    
    height = room_height;
    for(h = segments[lowest].y; h &lt;= room_height; h+=global.segmentSize)
    {
        if(h != room_height)
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( position_meeting(ghosts[i].x+1, h-(ghosts[lowest].y-ghosts[i].y)+1, obj_segment) )
                {
                    if( collision_point(ghosts[i].x+1, h-(ghosts[lowest].y-ghosts[i].y)+1, obj_segment, false, false).parent != id  )
                    {
                        height = h;
                        h = room_height;
                        hit = i;
                        i = 4;
                    }    
                }
            } 
        }
        else
        {
            hit = 0;
            for(i = 0; i &lt; 4; i++)
            {
                if( ghosts[i].y &gt; hit ) { hit = i; }
            }
        }
           
    }
    
    base = ghosts[lowest].y - ghosts[hit].y;
    
    for(i = 0; i &lt; 4; i++) 
    {
        ghosts[i].y = height - base - (segments[hit].y - segments[i].y);
    }    
}   
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.active == id)
{   
    canFall = true;
//    show_debug_message(alarm[3])
//    show_debug_message(slideDir)    

//    if(keyboard_check(ord("F"))) { speeding = 4; }
//    else { speeding = 1; }
    
    if(y &gt;= room_height) //stop it from falling through
    { 
        y = room_height;
        falling = false; 
    }
    else //Can it start falling again?
    {
        for(i = 0; i &lt; 4; i++)    
        {
            if( collision_point(segments[i].x+10, segments[i].y+global.segmentSize-10, obj_segment, false, false) != noone) 
            {
                if( collision_point(segments[i].x+10, segments[i].y+global.segmentSize-10, obj_segment, false, false).parent != id  )
                {
                    i = 4;
                    canFall = false;
                }
            }
        }
    }
    
    if ( canFall and alarm[0] = -1) 
    {
        alarm[1] = -1
//        alarm[0] = global.levels[global.level]/speeding;
        falling = true;
    }
}
else { alarm[0] = -1; }

if(falling) { IG += global.fallSpeed; }
time += delta_time/10000;

//if(IG &gt;= 2) { show_debug_message("WOAH DUDE!"); }

if(global.active == id and IG &gt; 1)
{    
    //show_debug_message(time);
    time = 0;    

    amt = floor(IG);
                
    lowest = 0;
    for(i = 0; i &lt; 4; i++) { if( segments[i].y &gt; segments[lowest].y) { lowest = i; } } 
            
    //If moving would move it past the bottom, automatically move straight there
    if(( segments[lowest].y+global.segmentSize*IG) &gt; room_height)    
    {
        yDiff = room_height - segments[lowest].y;
        for(i = 0; i &lt; 4; i++) { segments[i].y += yDiff; }
        if(alarm[1] == -1) { alarm[1] = global.timeToMove; } 
    }
    
    //Otherwise...
    else 
    {
        hit = false;
        lowestPart = lowest;
        lowestPlace = segments[lowest].y//+amt*global.segmentSize;
        
        for(i = 0; i &lt; 4; i++) //For each segment
        {
            for(j = segments[i].y+10;  j &lt; segments[i].y+amt*global.segmentSize; j+=global.segmentSize) //For each height
            {
                //Is there someone already 
                if( collision_point( segments[i].x+10, j, obj_segment, false, true) != noone ) 
                {
                    if( collision_point( segments[i].x+10, j, obj_segment, false, true).parent != id  )
                    {
                        hit = true;
                        lowestPart = i;
                        lowestPlace = j-10//-global.segmentSize;
                        j = room_height*2;
                        //show_debug_message("COLLISION AT " + string(lowestPlace));
                    }
                }
                if(j == room_height*2) { break; } 
            }
            if(j == room_height*2) { break; } 
        }    
        show_debug_message(lowest)
        if(!hit) 
        { 
            //show_debug_message("NO COLLISION AT " + string(segments[lowestPart].y)); 
            if( collision_point( segments[lowest].x+10, segments[lowest].y+10, obj_segment, false, true) == noone ) 
                { for(i = 0; i &lt; 4; i++) { segments[i].y += amt*global.segmentSize; }  } 
        }
        else 
        {
            alarm[1] = room_speed/2; //30 frames to solidify
            yDiff = lowestPlace - segments[lowestPart].y ;
            for(i = 0; i &lt; 4; i++) { segments[i].y += yDiff; }  
        } 
    }
    
    IG = 0;   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rotate clockwise

if(global.active == id)
{
    if(alarm[1] != -1) 
    { alarm[1] = global.timeToMove; }
    
    canMove = true;
    failed = false;
    
    for(i = 0; i &lt; 4; i++)
    {
        oldX[i] = segments[i].x;
        oldY[i] = segments[i].y;
    }

    //LONG ROTATION RULES
    if(type = "long")
    {
        if ( rot == 0 or rot == 180 ) //To horizontal
        {
            for(i = 0; i &lt; 4; i++) { segments[i].y = segments[2].y; }
            
            segments[3].x = segments[2].x + global.segmentSize*1;
            segments[1].x = segments[2].x - global.segmentSize*1;
            segments[0].x = segments[2].x - global.segmentSize*2;                                        
            
        }
        else if ( rot == 90 or rot == 270 ) //To vertical
        {
            for(i = 0; i &lt; 4; i++) { segments[i].x = segments[2].x; }
             
            segments[3].y = segments[2].y - global.segmentSize*1;
            segments[1].y = segments[2].y + global.segmentSize*1;
            segments[0].y = segments[2].y + global.segmentSize*2;
        }
        
        if ( rot == 0 or rot == 180 ) //Now horizontal
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( (segments[i].x &gt; global.width-global.segmentSize) or (segments[i].x &lt; 0) )
                { failed = true; }
                else if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false).parent != id ) 
                    { failed = true; }
                }  
            }
            
            if (failed)
            {
                right1 = true;
                right2 = true;
                left = true;
                up = true;
                
                for(j = 0; j &lt; 4; j++)
                {
                    //Can bump one right
                    if( (segments[j].x + global.segmentSize &gt;= global.width) or (segments[j].x + 10 + global.segmentSize &lt; 0) )
                    { right1 = false; }
                    else if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            right1 = false;              
                        }
                    }
                    
                    //Can bump two right
                    if( (segments[j].x + global.segmentSize*2 &gt;= global.width) or (segments[j].x + global.segmentSize*2 &lt; 0) )
                    { right2 = false; }
                    else if ( collision_point(segments[j].x+global.segmentSize*2+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+global.segmentSize*2+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            right2 = false;              
                        }
                    }
                    
                    //Can bump one left
                    if( (segments[j].x - global.segmentSize &gt;= global.width) or (segments[j].x - global.segmentSize &lt; 0) )
                    { left = false; }
                    else if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            left = false;              
                        }
                    }
                }
                
                if (right1)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x += global.segmentSize; } 
                }
                else if (right2)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x += global.segmentSize*2; } 
                }
                else if(left)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x -= global.segmentSize; } 
                }
                else
                {
                    for(j = 0; j &lt; 4; j++)
                    {
                        segments[j].x = oldX[j];
                        segments[j].y = oldY[j];
                    }
                    rot += 90;
                }
            }
        }
        else //Now vertical
        {
            for(i = 0; i &lt; 4; i++) //For as many up as it needs to go
            {
                for(j = 0; j &lt; 4; j++) //For each segment
                {
                    if ( collision_point(segments[j].x+10, segments[j].y-global.segmentSize*i-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+10, segments[j].y-global.segmentSize*i-10, obj_segment, false, false).parent != id ) 
                        { j = 10; }
                    }   
                }
                
                if( j &gt; 7 ) //No collision, you're good
                {
                    for( j = 0; j &lt; 4; j++ ) { segments[j].y -= global.segmentSize*i; } 
                    i = 10;
                }
            }
            
            if( i &gt; 7) //Never got free
            {
                for(j = 0; j &lt; 4; j++)
                {
                    segments[j].x = oldX[j];
                    segments[j].y = oldY[j];
                }
                rot += 90;
            }    
        }
        
        rot -= 90;
        if(rot == -90) { rot = 270; }  
    }
    else
    {
        /*else if (type == "square")
        {
            //show_debug_message("HURR.")
        }
        else*/
        if(type = "l")
        {
            if (rot == 0 ) //Flat at bottom to flat at right
            {   
                segments[0].y -= global.segmentSize;
                segments[1].x += global.segmentSize;
                segments[2].y += global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y += global.segmentSize*2;
            }
            else if ( rot == 90 ) //Flat at right to top
            {
                if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                if(!failed)
                {
                    segments[0].x -= global.segmentSize*2;
                    segments[0].y -= global.segmentSize;
                    segments[1].y -= global.segmentSize*2;
                    segments[1].x -= global.segmentSize;
                    segments[2].y -= global.segmentSize;
                    segments[3].x += global.segmentSize;
                }
            }
            else if ( rot == 180 ) //Flat at top to flat at left   
            {
                segments[3].x = segments[2].x + global.segmentSize;
                segments[3].y = segments[2].y;
                segments[1].x = segments[2].x - global.segmentSize;
                segments[1].y = segments[2].y;
                segments[0].y = segments[1].y + global.segmentSize;
            }
            else if (rot == 270) //Flat at left to bottom
            {
                if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                
                if(!failed)
                {
                    segments[3].x -= global.segmentSize;
                    segments[3].y -= global.segmentSize;
                    segments[1].x += global.segmentSize;
                    segments[1].y += global.segmentSize;
                    segments[0].x += global.segmentSize*2;  
                }    
            }   
        }
        
        //J AKA RL ROTATION RULES
        else if(type = "rl")
        {
            if(rot == 0 ) //Flat at bottom to right
            {
                segments[0].x += global.segmentSize*2;  
                segments[1].x += global.segmentSize;
                segments[1].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y += global.segmentSize;
            }
            else if(rot == 90)
            {}
            else if(rot == 180) //Top to left
            {
                 segments[0].x -= global.segmentSize*2;
                 segments[0].y += global.segmentSize;
                 segments[1].x -= global.segmentSize;
                 segments[1].y += global.segmentSize*2;
                 segments[2].y += global.segmentSize;
                 segments[3].x += global.segmentSize;
                 
                 
            }
            
            
            /*
            if ( rot == 0 ) //Flat at top to left
            {
                segments[0].x += global.segmentSize*2;
                segments[1].x += global.segmentSize;
                segments[1].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y += global.segmentSize;
            }
            else if ( rot == 90 ) //Flat at left to bottom
            {
                if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
            
                segments[0].y += global.segmentSize;
                segments[1].x += global.segmentSize;
                segments[2].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y -= global.segmentSize*2;
            }
            else if ( rot == 180 ) //Flat at bottom to flat at right   
            {
                segments[3].x += global.segmentSize;
                segments[2].y += global.segmentSize;
                segments[1].y = segments[2].y;
                segments[1].x -= global.segmentSize;
                segments[0].x = segments[1].x;
                segments[0].y += global.segmentSize;
            }
            else if (rot == 270) //Flat at left to top
            {
                if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                
                if(!failed)
                {
                    segments[0].y -= global.segmentSize*2;
                    segments[1].y -= global.segmentSize;
                    segments[1].x -= global.segmentSize;
                    segments[3].x += global.segmentSize;
                    segments[3].y += global.segmentSize;
                }    
            }
            */
        }
        else if(type = "t")
        {
            if (rot == 0 ) //pointing down
            {
                if ( collision_point(segments[0].x+10, segments[0].y-10-global.segmentSize, obj_segment, false, false) != noone )
                { 
                    failed = true; 
                    rot += 90;
                }
                else
                {
                    segments[1].x = segments[2].x;
                    segments[1].y = segments[2].y;
                    segments[2].x = segments[3].x;
                    segments[2].y = segments[3].y;
                    segments[3].x -= global.segmentSize;
                    segments[3].y -= global.segmentSize;
                }
            }
            else if ( rot == 90 ) 
            {
                if ( collision_point(segments[0].x+10, segments[0].y-10-global.segmentSize*2, obj_segment, false, false) != noone )
                { 
                    failed = true; 
                    rot += 90;
                }
                else
                {
                    segments[1].x = segments[2].x;
                    segments[1].y = segments[2].y;
                    segments[2].x = segments[3].x;
                    segments[2].y = segments[3].y;
                    segments[3].x -= global.segmentSize;
                    segments[3].y += global.segmentSize;
                }
            }
            else if ( rot == 180 )   
            {
                segments[1].x = segments[2].x;
                segments[1].y = segments[2].y;
                segments[2].x = segments[3].x;
                segments[2].y = segments[3].y;
                segments[3].x += global.segmentSize;
                segments[3].y += global.segmentSize;
            }
            else if (rot == 270) 
            {
                segments[1].x = segments[2].x;
                segments[1].y = segments[2].y;
                segments[2].x = segments[3].x;
                segments[2].y = segments[3].y;
                segments[3].x += global.segmentSize;
                segments[3].y -= global.segmentSize;
            }
        }
        else if ( type == "s" ) 
        {
            if(rot == 180 or rot == 0) // s to steps down right
            {
                segments[0].y -= global.segmentSize*2;
                segments[1].x -= global.segmentSize;
                segments[1].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y += global.segmentSize;
            }
            else if (rot == 270 or rot == 90) //steps down right to s 
            {
                segments[0].y -= global.segmentSize*2;
                segments[1].x -= global.segmentSize;
                segments[1].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y += global.segmentSize;
            }  
        }
        else if ( type == "z" ) 
        {
            if(rot == 180 or rot == 0) // z to steps down left
            {
                segments[0].x += global.segmentSize*2;
                segments[0].y -= global.segmentSize;
                segments[1].x += global.segmentSize;
                segments[2].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
            }
            else if (rot == 270 or rot == 90) //steps down left to z 
            {
                segments[0].x -= global.segmentSize*2;
                segments[0].y += global.segmentSize;
                segments[1].x -= global.segmentSize;
                segments[2].y += global.segmentSize;
                segments[3].x += global.segmentSize;
            }  
        }
        
        for(i = 0; i &lt; 4; i++)
        {
            if( (segments[i].x &gt; global.width-global.segmentSize) or (segments[i].x &lt; 0) )
            { failed = true; }
            else if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false) != noone )
            {
                if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false).parent != id ) 
                { failed = true; }
            }  
            
            if (failed)
            {
                left = true;
                right = true;
                up = true;
                
                for(j = 0; j &lt; 4; j++)
                {
                    //Can bump left
                    if( (segments[j].x - global.segmentSize &gt;= global.width) or (segments[j].x - global.segmentSize &lt; 0) )
                    { left = false; }
                    else if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            left = false;              
                        }
                    }
                    
                    //Can bump right
                    if( (segments[j].x + global.segmentSize &gt;= global.width) or (segments[j].x + global.segmentSize &lt; 0) )
                    { right = false; }
                    else if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            right = false;              
                        }
                    }
                    
                }
                
                if(left)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x -= global.segmentSize; } 
                }
                else if (right)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x += global.segmentSize; } 
                }
                else
                {
                    for(j = 0; j &lt; 4; j++)
                    {
                        segments[j].x = oldX[j];
                        segments[j].y = oldY[j];
                    }
                    rot += 90;
                }
                
                i = 4;
            }
        }
        
        rot -= 90;
        if(rot == -90) { rot = 270; }        
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///If not already on right, check right, then move one slot over
if(alarm[1] != -1) 
{ alarm[1] = global.timeToMove; }

if(global.active == id)
{   
    canMove = true;
    if(moving)
    {
        rightMost = 0; 
        for(i = 0; i &lt; 4; i++) 
        { 
            if( (segments[i]).x &gt; (segments[rightMost]).x ) 
            { rightMost = i; } 
        }
        
        if(segments[rightMost].x+10+(global.segmentSize) &lt; global.width) 
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( collision_point( segments[i].x+global.segmentSize+10, segments[i].y-10, obj_segment, false, true) != noone ) 
                {
                    if( collision_point( segments[i].x+global.segmentSize+10, segments[i].y-10, obj_segment, false, true).parent != id  )
                    {
                        canMove = false;
                        i = 4;
                    }    
                }
            }
        }
        else { canMove = false }
    
        if(canMove)
        {
            for(i = 0; i &lt; 4; i++)
            {
                segments[i].x += global.segmentSize;
            }
        }
    }  
    
    if(alarm[3] == -1)
    {
        //show_debug_message("PRESSED")   
        alarm[3] = autoIncDelay;
        slideDir = "r"
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rotate clockwise

if(global.active == id)
{
    if(alarm[1] != -1) 
    { alarm[1] = global.timeToMove; }
    
    canMove = true;
    failed = false;
    
    for(i = 0; i &lt; 4; i++)
    {
        oldX[i] = segments[i].x;
        oldY[i] = segments[i].y;
    }

    //LONG ROTATION RULES
    if(type = "long")
    {
        if ( rot == 0 or rot == 180 ) //To horizontal
        {
            for(i = 0; i &lt; 4; i++) { segments[i].y = segments[2].y; }
            
            segments[3].x = segments[2].x + global.segmentSize*1;
            segments[1].x = segments[2].x - global.segmentSize*1;
            segments[0].x = segments[2].x - global.segmentSize*2;                                       
            
        }
        else if ( rot == 90 or rot == 270 ) //To vertical
        {
            for(i = 0; i &lt; 4; i++) { segments[i].x = segments[2].x; }
             
            segments[3].y = segments[2].y - global.segmentSize*1;
            segments[1].y = segments[2].y + global.segmentSize*1;
            segments[0].y = segments[2].y + global.segmentSize*2;
        }
        
        if ( rot == 0 or rot == 180 ) //Now horizontal
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( (segments[i].x &gt; global.width-global.segmentSize) or (segments[i].x &lt; 0) )
                { failed = true; }
                else if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false).parent != id ) 
                    { failed = true; }
                }  
            }
            
            if (failed)
            {
                right1 = true;
                right2 = true;
                left = true;
                up = true;
                
                for(j = 0; j &lt; 4; j++)
                {
                    //Can bump one right
                    if( (segments[j].x + global.segmentSize &gt;= global.width) or (segments[j].x + 10 + global.segmentSize &lt; 0) )
                    { right1 = false; }
                    else if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            right1 = false;              
                        }
                    }
                    
                    //Can bump two right
                    if( (segments[j].x + global.segmentSize*2 &gt;= global.width) or (segments[j].x + global.segmentSize*2 &lt; 0) )
                    { right2 = false; }
                    else if ( collision_point(segments[j].x+global.segmentSize*2+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+global.segmentSize*2+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            right2 = false;              
                        }
                    }
                    
                    //Can bump one left
                    if( (segments[j].x - global.segmentSize &gt;= global.width) or (segments[j].x - global.segmentSize &lt; 0) )
                    { left = false; }
                    else if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            left = false;              
                        }
                    }
                }
                
                if (right1)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x += global.segmentSize; } 
                }
                else if (right2)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x += global.segmentSize*2; } 
                }
                else if(left)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x -= global.segmentSize; } 
                }
                else
                {
                    for(j = 0; j &lt; 4; j++)
                    {
                        segments[j].x = oldX[j];
                        segments[j].y = oldY[j];
                    }
                    rot += 90;
                }
            }
        }
        else //Now vertical
        {
            for(i = 0; i &lt; 4; i++) //For as many up as it needs to go
            {
                for(j = 0; j &lt; 4; j++) //For each segment
                {
                    if ( collision_point(segments[j].x+10, segments[j].y-global.segmentSize*i-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+10, segments[j].y-global.segmentSize*i-10, obj_segment, false, false).parent != id ) 
                        { j = 10; }
                    }   
                }
                
                if( j &gt; 7 ) //No collision, you're good
                {
                    for( j = 0; j &lt; 4; j++ ) { segments[j].y -= global.segmentSize*i; } 
                    i = 10;
                }
            }
            
            if( i &gt; 7) //Never got free
            {
                for(j = 0; j &lt; 4; j++)
                {
                    segments[j].x = oldX[j];
                    segments[j].y = oldY[j];
                }
                rot += 90;
            }    
        }
        
        rot -= 90;
        if(rot == -90) { rot = 270; }  
    }
    else
    {
        /*else if (type == "square")
        {
            //show_debug_message("HURR.")
        }
        else*/
        if(type = "l")
        {
            if (rot == 0 ) //Flat at bottom to flat at left
            {   
                 segments[3].x = segments[2].x + global.segmentSize;
                 segments[3].y = segments[2].y;
                 segments[1].x = segments[2].x - global.segmentSize;
                 segments[1].y = segments[2].y;
                 segments[0].x = segments[1].x;
            }
            else if ( rot == 90 ) //Flat at right to bottom
            {
                if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                if(!failed)
                {
                    segments[0].y = segments[1].y;
                    segments[1].x = segments[2].x;
                    segments[2].y = segments[2].y - global.segmentSize;
                    segments[3].x = segments[2].x;
                    segments[3].y = segments[2].y - global.segmentSize;
                }
            }
            else if ( rot == 180 ) //Flat at top to flat at right   
            {
                segments[3].x -= global.segmentSize;
                segments[2].y += global.segmentSize;
                segments[1].x += global.segmentSize;
                segments[1].y = segments[2].y;
                segments[0].x = segments[1].x;
                segments[0].y += global.segmentSize;
            }
            else if (rot == 270) //Flat at left to top
            {
                if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                
                if(!failed)
                {
                    segments[0].y -= global.segmentSize*2;
                    segments[1].x += global.segmentSize;
                    segments[1].y -= global.segmentSize;
                    segments[3].x -= global.segmentSize;
                    segments[3].y += global.segmentSize;  
                }    
            }   
        }
        
        //J AKA RL ROTATION RULES
        else if(type = "rl")
        {
            if ( rot == 0 ) //Flat at bottom to left
            {
                segments[0].y -= global.segmentSize;
                segments[1].x -= global.segmentSize;
                segments[2].y += global.segmentSize;
                segments[3].x += global.segmentSize;
                segments[3].y += global.segmentSize*2;
            }
            else if ( rot == 90 ) //Flat at right to bottom
            {
                if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y+global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
            
                segments[0].x -= global.segmentSize*2;
                segments[1].x -= global.segmentSize;
                segments[1].y += global.segmentSize;
                segments[3].x += global.segmentSize;
                segments[3].y -= global.segmentSize;
            }
            else if ( rot == 180 ) //Flat at top to flat at right   
            {
                segments[3].x -= global.segmentSize;
                segments[3].y -= global.segmentSize;
                segments[1].y += global.segmentSize;
                segments[1].x += global.segmentSize;
                segments[0].y += global.segmentSize*2;
            }
            else if (rot == 270) //Flat at left to top
            {
                if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                else if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false) != noone )
                {
                    if ( collision_point(segments[2].x+10, segments[2].y-global.segmentSize*2-10, obj_segment, false, false).parent != id )     
                    { failed = true; } 
                }
                
                if(!failed)
                {
                    segments[3].x -= global.segmentSize;
                    segments[2].y -= global.segmentSize;
                    segments[1].x += global.segmentSize;
                    segments[1].y -= global.segmentSize*2;
                    segments[0].x += global.segmentSize*2;
                    segments[0].y -= global.segmentSize; 
                }    
            }
        }
        else if(type = "t")
        {
            if (rot == 0 ) //pointing down
            {
                if ( collision_point(segments[0].x+10, segments[0].y-10-global.segmentSize, obj_segment, false, false) != noone )
                { 
                    failed = true; 
                    rot += 90;
                }
                else
                {
                    segments[3].x = segments[2].x;
                    segments[3].y = segments[2].y;
                    segments[2].x = segments[1].x;
                    segments[2].y = segments[1].y;
                    segments[1].x += global.segmentSize;
                    segments[1].y -= global.segmentSize;
                }
            }
            else if ( rot == 90 ) //pointing right
            {
                segments[3].x = segments[2].x;
                segments[3].y = segments[2].y;
                segments[2].x = segments[1].x;
                segments[2].y = segments[1].y;
                segments[1].x -= global.segmentSize;
                segments[1].y -= global.segmentSize;
            }
            else if ( rot == 180 ) //facing up
            {
                if ( collision_point(segments[0].x+10, segments[0].y-10-global.segmentSize*2, obj_segment, false, false) != noone )
                { 
                    failed = true; 
                    rot += 90;
                }
                else
                {
                    segments[3].x = segments[2].x;
                    segments[3].y = segments[2].y;
                    segments[2].x = segments[1].x;
                    segments[2].y = segments[1].y;
                    segments[1].x -= global.segmentSize;
                    segments[1].y += global.segmentSize;
                }
            }
            else if (rot == 270) //pointing left
            {
                segments[3].x = segments[2].x;
                segments[3].y = segments[2].y;
                segments[2].x = segments[1].x;
                segments[2].y = segments[1].y;
                segments[1].x += global.segmentSize;
                segments[1].y += global.segmentSize;
            }
        }
        else if ( type == "s" ) 
        {
            if(rot == 180 or rot == 0) // s to steps down right
            {
                segments[0].y -= global.segmentSize*2;
                segments[1].x -= global.segmentSize;
                segments[1].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
                segments[3].y += global.segmentSize;
            }
            else if (rot == 270 or rot == 90) //steps down right to s 
            {
                segments[0].y += global.segmentSize*2;
                segments[1].x += global.segmentSize;
                segments[1].y += global.segmentSize;
                segments[3].x += global.segmentSize;
                segments[3].y -= global.segmentSize;
            }  
        }
        else if ( type == "z" ) 
        {
            if(rot == 180 or rot == 0) // z to steps down left
            {
                segments[0].x += global.segmentSize*2;
                segments[0].y -= global.segmentSize;
                segments[1].x += global.segmentSize;
                segments[2].y -= global.segmentSize;
                segments[3].x -= global.segmentSize;
            }
            else if (rot == 270 or rot == 90) //steps down left to z 
            {
                segments[0].x -= global.segmentSize*2;
                segments[0].y += global.segmentSize;
                segments[1].x -= global.segmentSize;
                segments[2].y += global.segmentSize;
                segments[3].x += global.segmentSize;
            }  
        }
        
        for(i = 0; i &lt; 4; i++)
        {
            if( (segments[i].x &gt; global.width-global.segmentSize) or (segments[i].x &lt; 0) )
            { failed = true; }
            else if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false) != noone )
            {
                if ( collision_point(segments[i].x+10, segments[i].y-10, obj_segment, false, false).parent != id ) 
                { failed = true; }
            }  
            
            if (failed)
            {
                left = true;
                right = true;
                up = true;
                
                for(j = 0; j &lt; 4; j++)
                {
                    //Can bump left
                    if( (segments[j].x - global.segmentSize &gt;= global.width) or (segments[j].x - global.segmentSize &lt; 0) )
                    { left = false; }
                    else if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x-global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            left = false;              
                        }
                    }
                    
                    //Can bump right
                    if( (segments[j].x + global.segmentSize &gt;= global.width) or (segments[j].x + global.segmentSize &lt; 0) )
                    { right = false; }
                    else if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false) != noone )
                    {
                        if ( collision_point(segments[j].x+global.segmentSize+10, segments[j].y-10, obj_segment, false, false).parent != id )     
                        {
                            right = false;              
                        }
                    }
                    
                }
                
                if(left)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x -= global.segmentSize; } 
                }
                else if (right)
                {
                    for(j = 0; j &lt; 4; j++) { segments[j].x += global.segmentSize; } 
                }
                else
                {
                    for(j = 0; j &lt; 4; j++)
                    {
                        segments[j].x = oldX[j];
                        segments[j].y = oldY[j];
                    }
                    rot += 90;
                }
                
                i = 4;
            }
        }
        
        rot -= 90;
        if(rot == -90) { rot = 270; }        
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///If not already on left, check left, then move one slot over
if(alarm[1] != -1) 
{ alarm[1] = global.timeToMove; }

canMove = true;
if(moving)
{
    leftmost = 0;
    for(i = 0; i &lt; 4; i++)
    {
        if( segments[i].x &lt; segments[leftmost].x ) { leftmost = i; }
    }

    if(segments[leftmost].x+10-global.segmentSize &gt; 0) 
    {
        for(i = 0; i &lt; 4; i++)
        {
            if( collision_point(segments[i].x-global.segmentSize+10, segments[i].y-10, obj_segment, false, false) != noone) 
            {
                if( collision_point(segments[i].x-global.segmentSize+10, segments[i].y-10, obj_segment, false, false).parent != id  )
                {
                    canMove = false;
                }    
            }
        }
    }
    else { canMove = false }

    if(canMove)
    {
        for(i = 0; i &lt; 4; i++)
        {
            segments[i].x -= global.segmentSize;
        }
    }
} 

if(alarm[3] == -1)
{
    alarm[3] = autoIncDelay;
    slideDir = "l"
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_peice</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Hard drop
height = room_height;
if(global.active == id and global.hardDrop)
{
    lowest = 0;
    for(i = 0; i &lt; 4; i++) 
    { 
        if( (segments[i]).y &gt; (segments[lowest]).y ) 
        { lowest = i; } 
    }
    
    for(h = segments[lowest].y; h &lt;= room_height; h+=global.segmentSize)
    {
        if(h != room_height)
        {
            for(i = 0; i &lt; 4; i++)
            {
                if( position_meeting(segments[i].x+1, h-(segments[lowest].y-segments[i].y)+1, obj_segment) )
                {
                    if( collision_point(segments[i].x+1, h-(segments[lowest].y-segments[i].y)+1, obj_segment, false, false).parent != id  )
                    {
                        height = h;
                        h = room_height;
                        hit = i;
                        i = 4;
                    }    
                }
            } 
        }
        else
        {
            hit = 0;
            for(i = 0; i &lt; 4; i++)
            {
                if( segments[i].y &gt; hit ) { hit = i; }
            }
        }
           
    }
    
    y = height;
    
    yDiff = height - segments[lowest].y;
    
    segments[0].y += yDiff;
    segments[1].y += yDiff;
    segments[2].y += yDiff;
    segments[3].y += yDiff;
    
    solidify(id);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>slideDir = " ";
alarm[3] = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>slideDir = " ";
alarm[3] = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
