<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.control = id;
var segSurf = surface_create(global.segmentSize, global.segmentSize);
surface_set_target(segSurf);
draw_clear(c_white);
surface_reset_target();
segmentSprite = sprite_create_from_surface(segSurf, 0, 0, global.segmentSize, global.segmentSize, false, false, 0, global.segmentSize);
sprite_collision_mask(segmentSprite, false, 1, 0, 0, 0, 0, 1, 0);
surface_free(segSurf);

average_fps = fps_real;
benchmark = false;
if(benchmark) { frames = ds_list_create(); }

UI_WIDTH = global.UI_PIXEL_WIDTH; //Local copy of ui_width;
WINDOW_WIDTH = global.WINDOW_WIDTH;
WINDOW_HEIGHT = global.WINDOW_HEIGHT;

global.hardDrop = true;
global.SOFT_DROP_SPEED = 5;
global.pieceC = 0;
global.canSpawnNew = true;

hardDropTimer = -1;
spawnPieceTimer = -1;
clearDelayTimer = -1;

global.clear_surf = surface_create(room_width, room_height);
global.clearedLines = ds_list_create();

global.clear_part_system = part_system_create();
part_system_automatic_draw(global.clear_part_system, false);
global.clear_part = part_type_create();
part_type_shape(global.clear_part, pt_shape_disk);
part_type_size(global.clear_part, .05, .1, 0, 0);
part_type_colour2(global.clear_part, c_white, c_black);
part_type_speed(global.clear_part, 1*room_speed/60, 2*room_speed/60, 0, 0);
part_type_direction(global.clear_part, 0, 360, 0, 0);
part_type_gravity(global.clear_part, 0.30*room_speed/60, 270);
part_type_life(global.clear_part, room_speed*1, room_speed*2);


for(i = 0; i &lt;= 500; ++i)
{
    if( i &lt; 30 and i &gt;= 0 ) { global.levels[i] = 4; }
    else if( i &lt; 35 and i &gt;= 30 ) { global.levels[i] = 6; }
    else if( i &lt; 40 and i &gt;= 35 ) { global.levels[i] = 8; }
    else if( i &lt; 50 and i &gt;= 40 ) { global.levels[i] = 8; }
    else if( i &lt; 60 and i &gt;= 50 ) { global.levels[i] = 10; }
    else if( i &lt; 70 and i &gt;= 60 ) { global.levels[i] = 12; }
    else if( i &lt; 80 and i &gt;= 70 ) { global.levels[i] = 16; }
    else if( i &lt; 90 and i &gt;= 80 ) { global.levels[i] = 32; }
    else if( i &lt; 100 and i &gt;= 90 ) { global.levels[i] = 48; }
    else if( i &lt; 120 and i &gt;= 100 ) { global.levels[i] = 64; }
    else if( i &lt; 140 and i &gt;= 120 ) { global.levels[i] = 80; }
    else if( i &lt; 160 and i &gt;= 140 ) { global.levels[i] = 96; }
    else if( i &lt; 170 and i &gt;= 160 ) { global.levels[i] = 112; }
    else if( i &lt; 200 and i &gt;= 170 ) { global.levels[i] = 128; }
    else if( i &lt; 220 and i &gt;= 200 ) { global.levels[i] = 144; }
    else if( i &lt; 230 and i &gt;= 220 ) { global.levels[i] = 4; }
    else if( i &lt; 233 and i &gt;= 230 ) { global.levels[i] = 32; }
    else if( i &lt; 236 and i &gt;= 233 ) { global.levels[i] = 64; }
    else if( i &lt; 239 and i &gt;= 236 ) { global.levels[i] = 128; }
    else if( i &lt; 243 and i &gt;= 239 ) { global.levels[i] = 160; }
    else if( i &lt; 247 and i &gt;= 243 ) { global.levels[i] = 192; }
    else if( i &lt; 251 and i &gt;= 247 ) { global.levels[i] = 224; }
    else if( i &lt; 300 and i &gt;= 251 ) { global.levels[i] = 256; }
    else if( i &lt; 330 and i &gt;= 300 ) { global.levels[i] = 512; }
    else if( i &lt; 360 and i &gt;= 330 ) { global.levels[i] = 768; }
    else if( i &lt; 400 and i &gt;= 360 ) { global.levels[i] = 1024; }
    else if( i &lt; 420 and i &gt;= 400 ) { global.levels[i] = 1280; }
    else if( i &lt; 450 and i &gt;= 420 ) { global.levels[i] = 1024; }
    else if( i &lt; 500 and i &gt;= 450 ) { global.levels[i] = 768; }
    else if( i == 500 ) { global.levels[i] = 5120; }
}
global.lines = 0;
global.level = 0;
//global.level = 230;
//global.level = 300;
//global.level = 500;
global.fallSpeed = global.levels[global.level]/256; //IGs (256 == 1G == 1 segment per frame at 60FPS)

//global.previewCount = 3;
preview_padded = 50;
global.previewCount = floor((window_get_height()-30-preview_padded)/preview_padded);

global.timeToMove = room_speed/60;

global.hold = " ";
type = " ";
canSwap = true;

randomize();

global.piece_list = ds_list_create();
ds_list_add(global.piece_list, "long");
ds_list_add(global.piece_list, "square");
ds_list_add(global.piece_list, "s");
ds_list_add(global.piece_list, "z");
ds_list_add(global.piece_list, "l");
ds_list_add(global.piece_list, "rl");
ds_list_add(global.piece_list, "t");

if(global.rand_method == "Full")
{
    preview[0] = "";
    for(i = 0; i &lt; global.previewCount; i++)
          { preview[i] = global.piece_list[| irandom_range(0, ds_list_size(global.piece_list)-1 )] } 
}
else if(global.rand_method == "Bag")
{
    global.bag = ds_list_create();
}

global.level++;


music = audio_play_sound(snd_ThemeA, 100, true);
audio_sound_gain(music, global.music_level/100, 0);


room_surf = surface_create(room_width+1, room_height);

grid_surf = surface_create(room_width+1, room_height); 
surface_free(grid_surf); //Free so that the grid draw to create the lines will trigger


global.ghostSurf = noone;
guiSurf = noone;

for(var _x = global.BLOCKS_WIDE-1; _x &gt;= 0; _x--)
{
    for(var _y = global.BLOCKS_TALL-1+4; _y &gt;= 0; _y--) //+4 to handle pieces off the top
    {
        global.segArr[_x, _y] = noone;
    }
}

global.canSpawnNew = false;
global.active = instance_create(0 , 0, obj_piece);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(benchmark) { ds_list_destroy(frames); }
ds_list_destroy(global.clearedLines);
ds_list_destroy(global.peice_list);
if(global.rand_method == "Bag") { ds_list_destroy(global.bag); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>average_fps = average_fps*0.99 + fps_real*0.01;
if(benchmark) { ds_list_add(frames, delta_time); }


if(global.in_p[? mkeys.menu])
{
    ///Pause
    global.paused = !global.paused;
    
    if(global.paused)
    {
        audio_pause_sound(music);
        global.timer_list = ds_list_create();
        if(global.active != noone)
        {
            global.timer_list[| 0] = global.active.nonmovementTimer;
                global.active.nonmovementTimer = -1;
            global.timer_list[| 1] = global.active.sliderTimer;
                global.active.sliderTimer = -1;
            global.timer_list[| 2] = global.active.rotationTimer;
                global.active.rotationTimer = -1;
            global.timer_list[| 3] = global.active.fallingTimer;
                global.active.fallingTimer = -1;
            instance_activate_object(global.pause_menu);   
        }
    }
    else
    {
        audio_resume_sound(music);
        if(global.active == noone)
        {
            global.active.nonmovementTimer = global.timer_list[| 0];
            global.active.sliderTimer = global.timer_list[| 1];
            global.active.rotationTimer = global.timer_list[| 2];
            global.active.fallingTimer = global.timer_list[| 3];
        }
        ds_list_destroy(global.timer_list);
        reset_pause();
        save_settings(true, true);
        instance_deactivate_object(global.pause_menu);
    }
}
else if(global.in[? gkeys.hold])
{
    if(canSwap and !global.paused and global.active != noone)
    {
        canSwap = false; 
        
        if( global.hold == " ")
        {
            global.hold = global.active.type;
            
            global.active.moving = false;
            for(i = 0; i &lt; 4; i++)
            {
                instance_destroy(global.active.segments[i]);
                instance_destroy(global.active.ghosts[i]);
            }
            instance_destroy(global.active);
            
            var snd = audio_play_sound(snd_bop, 10, false);
            audio_sound_gain(snd, global.sfx_level/100, 0);
            
            //newPeice
            global.canSpawnNew = false;
            global.active = instance_create(0 , 0, obj_piece);
        }
        else 
        {
            tmp = global.hold;
            global.hold = global.active.type;
            
            global.active.moving = false;
            for(i = 0; i &lt; 4; i++)
            {
                instance_destroy(global.active.segments[i]);
                instance_destroy(global.active.ghosts[i]);
            }
            instance_destroy(global.active);
             
            global.control.type = tmp;
            
            var snd = audio_play_sound(snd_bop, 10, false);
            audio_sound_gain(snd, global.sfx_level/100, 0);
            
            //newPeice
            global.canSpawnNew = false;
            global.active = instance_create(0 , 0, obj_piece);
        }
        
        with(obj_segment) { visible = true; } 
    }
}



if(!global.hardDrop and hardDropTimer == -1) { hardDropTimer = 1/60; }
if(hardDropTimer &gt; -1) 
{ 
    hardDropTimer -= delta_time/1000000*60; 
    if(hardDropTimer &lt;= 0 and hardDropTimer != -1) 
    { 
        global.hardDrop = true; 
        hardDropTimer = -1; 
    }
}

if(!surface_exists(global.clear_surf)) { global.clear_surf = surface_create(room_width, room_height); } 
surface_set_target(global.clear_surf);
draw_clear_alpha(c_black, 0);
surface_reset_target();

if(!global.canSpawnNew)
{
    if(clearDelayTimer &gt; -1) 
    {
        clearDelayTimer -= delta_time/1000000*60;
        if(clearDelayTimer &lt;= 0)
        {
            instance_destroy(obj_phantomSeg);
            for(var _i = ds_list_size(global.clearedLines)-1; _i &gt;= 0; _i-- )
            {
                moveLinesDown(global.clearedLines[| _i]);
            }
            ds_list_clear(global.clearedLines);
            if(surface_exists(global.STATIC_SEGMENT_SURFACE)) 
            { 
                surface_free(global.STATIC_SEGMENT_SURFACE); 
                with(obj_segment) { visible = true; } 
            }
            clearDelayTimer = -1;
            
            global.canSpawnNew = false;
            global.active = instance_create(0 , 0, obj_piece);
        }
    }
    else if(spawnPieceTimer == -1) { spawnPieceTimer = 1/60; }
    if(spawnPieceTimer &gt; -1) 
    { 
        spawnPieceTimer -= delta_time/1000000*60; 
        if(spawnPieceTimer &lt;= 0  and spawnPieceTimer != -1) 
        { 
            global.canSpawnNew = true;
            spawnPieceTimer = -1; 
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(benchmark)
{
    var f = file_text_open_write("frame_times.csv");
    for(var _i = 0; _i &lt; ds_list_size(frames) - 2; _i++)
    {
        file_text_write_string(f, string(frames[| _i]) + ", ");
    }
    file_text_write_string(f, string(frames[| ds_list_size(frames)-1]));
    file_text_close(f);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///If the surface for the static segments has been destroyed, 
//recreate and ready the segments for redrawing onto it
if(!surface_exists(global.STATIC_SEGMENT_SURFACE))
{
    //If the suface was destroyed, recreate it and make all segments redraw themselves onto it once
    global.STATIC_SEGMENT_SURFACE = surface_create(room_width, room_height);
    with(obj_segment) { visible = true; }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_set_target(room_surf);
draw_clear_alpha(c_black, 0);
surface_reset_target();

if(!global.paused and global.active != noone)
{
    surface_set_target(room_surf);
    if(global.ghost) 
    {
        draw_surface(global.ghostSurf, global.active.ghostX*global.segmentSize, global.active.ghostY*global.segmentSize); 
    }
    draw_surface(global.active.surf, global.active.x*global.segmentSize, global.active.y*global.segmentSize);
    surface_reset_target();
}

surface_set_target(room_surf);
draw_surface(global.clear_surf, 0, 0);
part_system_drawit(global.clear_part_system);
draw_surface(global.STATIC_SEGMENT_SURFACE, 0, 0);
if(global.grid) { draw_surface(grid_surf, 0, 0); }
surface_reset_target();


draw_surface(room_surf, global.GUI_LEFT_SIZE, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!surface_exists(room_surf)) 
{ 
    room_surf = surface_create(room_width+1, room_height); 
    surface_set_target(room_surf);
    draw_clear_alpha(c_black, 0);
    surface_reset_target();
} 
if(!surface_exists(global.clear_surf)) 
{ 
    global.clear_surf = surface_create(room_width, room_height); 
    surface_set_target(global.clear_surf);
    draw_clear_alpha(c_black, 0);
    surface_reset_target();
} 
/* //IN prepareGhostSurface() 
if(global.ghost and !surface_exists(global.ghostSurf)) 
{ 
    global.ghostSurf = surface_create(4*global.segmentSize, 4*global.segmentSize);
    surface_set_target(global.ghostSurf);
    draw_clear_alpha(c_black, 0); 
    surface_reset_target();
} 
*/
if(global.ghost and !surface_exists(global.ghostSurf)) 
    { with(global.active) { prepareGhostSurface(); } }

if(global.grid and !surface_exists(grid_surf))
{
    grid_surf = surface_create(room_width+1, room_height); 
    surface_set_target(grid_surf);
    draw_clear_alpha(c_black, 0);
    //VERTICAL
    draw_set_color(c_black);
    for(var _x = 0; _x &lt;= room_width; _x += global.segmentSize)
        { draw_line(_x, 0, _x, room_height); }
    //HORIZONTAL
    for(var _y = 0; _y &lt;= room_height; _y += global.segmentSize)
        { draw_line(0, _y, room_width, _y); }
    surface_reset_target();
}

if(!surface_exists(global.STATIC_SEGMENT_SURFACE))
{
    show_debug_message("REBUILDING");
    //If the suface was destroyed, recreate it and make all segments redraw themselves onto it once
    global.STATIC_SEGMENT_SURFACE = surface_create(room_width, room_height);
    with(obj_segment) { visible = true; }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_valign(fa_top);
draw_set_halign(fa_center);

right_center = window_get_width() - global.GUI_RIGHT_SIZE/2; 
preview_size = 40;
preview_padded = 50;

fnt_height = 40;

if(!surface_exists(guiSurf))
{
    draw_set_color(c_black);
    guiSurf = surface_create(view_wview[0], view_hview[0]);
    surface_set_target(guiSurf);
    
    draw_set_colour(c_white);
    draw_rectangle(0, 0, global.GUI_LEFT_SIZE-1, window_get_height(), false);
    draw_rectangle(window_get_width()-global.GUI_RIGHT_SIZE+1, 0, window_get_width(), window_get_height(), false);
    
    draw_set_color(c_black);
    draw_rectangle(right_center-preview_padded/2, 10, right_center+preview_padded/2, 10+preview_padded, true);
    draw_line_width(right_center - global.GUI_RIGHT_SIZE/2*0.8, preview_padded+20, right_center + global.GUI_RIGHT_SIZE/2*0.8, preview_padded+20, 3);
    for(i = 0; i &lt; global.previewCount; i++)
        { draw_rectangle(right_center-preview_padded/2, 30+preview_padded*(1+i), right_center+preview_padded/2, 30+preview_padded*(2+i), true); }
        
    draw_set_font(my_huge_font);
    var txt_width = string_width("LINES");
    var txt_height = string_height("LINES");
    var scale = min((global.GUI_LEFT_SIZE-20)/txt_width, fnt_height/txt_height);
    draw_text_transformed(global.GUI_LEFT_SIZE/2, 10, "LINES", scale, scale, 0);
    
    txt_height = string_height("LEVEL");
    txt_width = string_width("LEVEL");
    scale = min((global.GUI_LEFT_SIZE-20)/txt_width, fnt_height/txt_height);
    draw_text_transformed(global.GUI_LEFT_SIZE/2, 45+fnt_height*2, "LEVEL", scale, scale, 0);
    
    surface_reset_target();
}

draw_surface(guiSurf, 0, 0);

if(!global.paused)
{ 
    draw_set_color(c_black);
    spr = asset_get_index("spr_" + global.hold);
    if(global.hold != " ") { draw_sprite(spr, 0, right_center-(sprite_get_width(spr)/2), 10+preview_padded/2-sprite_get_height(spr)/2); }
    if(!canSwap) 
    { 
        draw_set_color(c_red);
        draw_line_width(right_center-(preview_padded/2), 10+preview_padded/2-preview_padded/2, right_center+(preview_padded/2), 10+preview_padded/2+preview_padded/2, 3);
        draw_line_width(right_center+(preview_padded/2), 10+preview_padded/2-preview_padded/2, right_center-(preview_padded/2), 10+preview_padded/2+preview_padded/2, 3);
        draw_set_color(c_black);
    }

    if(global.rand_method == "Full")
    {
        for(i = 0; i &lt; global.previewCount; i++)
        {
            spr = asset_get_index("spr_" + preview[i]);
            draw_sprite(spr, 0, right_center-(sprite_get_width(spr)/2), 30+preview_padded*(1.5+i)+sprite_get_height(spr)/2); 
        } 
    }
    else if(global.rand_method == "Bag")
    {
        for(i = 0; i &lt; global.previewCount; i++)
        {
            spr = asset_get_index("spr_" + global.bag[| i]);
            draw_sprite(spr, 0, right_center-(sprite_get_width(spr)/2), 30+preview_padded*(1.5+i)-sprite_get_height(spr)/2);
        }
    }

    draw_set_font(my_huge_font);
    
    var txt_width = string_width(string(global.lines));
    var txt_height = string_height(string(global.lines));
    var scale = min((global.GUI_LEFT_SIZE-20)/txt_width, fnt_height/txt_height);
    draw_text_transformed(global.GUI_LEFT_SIZE/2, 15+fnt_height, string(global.lines), scale, scale, 0); 

    txt_width = string_width(string(global.level));
    txt_height = string_height(string(global.lines));
    scale = min((global.GUI_LEFT_SIZE-20)/txt_width, fnt_height/txt_height);
    draw_text_transformed(global.GUI_LEFT_SIZE/2, 50+fnt_height*3, string(global.level), scale, scale, 0); 
}


if(global.debug_overlay)
{
    draw_set_valign(fa_bottom);
    draw_set_halign(fa_left);
    draw_set_font(my_font);
    draw_set_color(c_white);
    draw_text_color_outline(10, 50, "FPS_REAL: " + string(fps_real), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(10, 50 + string_height("FPS"), "FPS_AVG: " + string(average_fps), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(10, 50 + string_height("FPS")*2, "DISPLAY_FPS: " + string(1000000/delta_time), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(10, 50 + string_height("FPS")*3, "FRAME_TIME (ms): " + string_format(delta_time/1000, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    
    if(global.active != noone)
    {
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*11, "slideDir: " + global.active.slideDir, c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*10, "0.y: " + string_format(global.active.segments[0].y, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*9, "1.y: " + string_format(global.active.segments[1].y, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*8, "2.y: " + string_format(global.active.segments[2].y, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*7, "3.y: " + string_format(global.active.segments[3].y, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*6, "CANFALL: " + string_format(global.active.canFall, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*5, "NONMOVE: " + string_format(global.active.nonmovementTimer, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*4, "ROTATE: " + string_format(global.active.rotationTimer, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*3, "FALLING: " + string_format(global.active.fallingTimer, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*2, "IG: " + string_format(global.active.IG, 5, 3), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    }
    else
    {
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*11, "slideDir: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*10, "0.y: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*9, "1.y: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*8, "2.y: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*7, "3.y: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*6, "CANFALL: N/A" , c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*5, "NONMOVE: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*4, "ROTATE: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*3, "FALLING: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
        draw_text_color_outline(10, view_hview[0]-10-string_height("IG")*2, "IG: N/A", c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);  
    }
    draw_text_color_outline(10, view_hview[0]-10-string_height("DROP"), "DROP_TIME: " + string(hardDropTimer), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(10, view_hview[0]-10, "CAN_HARD: " + boolean_replace(global.hardDrop, "oo"), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
     
    draw_set_halign(fa_right);
    draw_text_color_outline(view_wview[0]-10, 50, "MENU: " + string(global.in[? mkeys.menu]) + " | " + string(global.in_p[? mkeys.menu]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*1, "HOLD: " + string(global.in[? gkeys.hold]) + " | " + string(global.in_p[? gkeys.hold]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*2, "LEFT: " + string(global.in[? gkeys.left]) + " | " + string(global.in_p[? gkeys.left]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*3, "RIGHT: " + string(global.in[? gkeys.right]) + " | " + string(global.in_p[? gkeys.right]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*4, "CW: " + string(global.in[? gkeys.cw]) + " | " + string(global.in_p[? gkeys.cw]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*5, "CCW: " + string(global.in[? gkeys.ccw]) + " | " + string(global.in_p[? gkeys.ccw]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*6, "HD: " + string(global.in[? gkeys.hd]) + " | " + string(global.in_p[? gkeys.hd]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
    draw_text_color_outline(view_wview[0]-10, 50 + string_height("FPS")*7, "SD: " + string(global.in[? gkeys.sd]) + " | " + string(global.in_p[? gkeys.sd]), c_white, c_white,  1, c_black, c_black, 1, 2, 3, 1, 1, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
